# Optimizing Conway's Game of Life in JavaScript - Part II

In [Part I](https://medium.com/@MisteRussell/optimizing-conways-game-of-life-in-javascript-part-i-a237039e3d26) I tackled solving the Puzzle of Conway's way of life iteratively through arrays. I had a few idea's of the direction that I wanted to go and after working through this further some of my assumptions were correct. Largely the code looks completely different, and I hope, improved. It looks cleaner to me at least. Here was my expected process:

## Process
1. <strike>Get the program to correctly generate new generations</strike>
2. Optimize the program so that it isn't wastefully processing
3. Change the structure of the Life maps from a 2D config to a toroidal config
4. Wireframe / Plan Visuals
5. Deploy to a React app

[For the full v2 code click here](./life.js)

I was able to successfully generate each subsequent generation with the array methods. My next goal was to tackle "optimization" as best I could. The initial array's that I'm starting with are small, so optimizing in this scenario is moving away from array enumeration. Semantics, right?

Before changing the model of my data, I will note, that it was quite easy to change the initial function from a `for` loop to a recursive function. This pleases me, because I sometimes struggle with recursion.

### Changing the data
I made drastic shifts to the form of the data and how it is stored, and some minor adjustments to what I wanted to keep track of for each cell.

#### Cell Creation - From Constructor to Factory
```
function Cell(x, y, cellState, neighbors = 0) {
  this.x = x;
  this.y = y;
  this.hash = (this.x * 15486047) + (this.y * 15487429);
  this.isAlive = cellState;
  this.neighbors = neighbors
 };
```
This let me save and access properties that I thought I would need. I only ended up needing two of these properties in the initail run of the program, `isAlive` and `neighbors`. The value `isAlive` kept track of if the cell was a `true` or `false`, and `neighbors` kept track of calculated value where any adjacent cells were also alive.

In v2 I have moved away from using a Constructor to using a factory. The factory picks up it's values from the function arguments and returns the new object. You'll note I'm also passing in a `toroidalLimits` arg, as I have changed the data structure to toroidal arrays. I will talk through why later.
 ```
function createCell(x, y, cellState, toroidalLimits){
  const cellHash = (x * 15486047) + (y * 15487429);
  const Cell = () => ({
    x,
    y,
    cellHash,
    cellState,
    toroidalLimits
  });

  return Cell();
};
```
#### Generation Management - From Array of Arrays to Object/Hashmap
To avoid needless array enumeration I have decided to move to an object of hashed objects to store my data. This allows me to target specific cells and skip having to look over cells that aren't neighbors of the cell I am looking at any specific moment in time.

One set of enumeration is required to generate the gen hashmap:
```
let genState = {};
  rawCells.forEach((terrian, i, arr) => {
    terrian.forEach((cell, p, arr2) => {
      const toroidalLimits = genState.toroidalLimits === undefined ? genState.toroidalLimits = [arr.length, arr2.length] : null;
      const cellState = cell;
      const cellObj = createCell(i + 1, p + 1, cellState, toroidalLimits);
      return genState[cellObj.cellHash] === undefined ? genState[cellObj.cellHash] = cellObj : null
    });
 });
return genState;
```
- I'm currently passing in the max horizontal and vertical index values to each cell. I will likely end up moving this to the main object.
